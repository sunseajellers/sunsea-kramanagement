# ğŸ’ JewelMatrix: Enterprise Digital Operating System

**Version 2.2.0 | Status: Production Ready | Last Updated: February 2026**

JewelMatrix is a high-performance, enterprise-grade **Digital Operating System (DOS)** designed to synchronize organizational strategy with daily tactical execution. It acts as a central nervous system for modern organizations, unifying **OKRs (Strategy)**, **Tasks (Execution)**, **Support (Operations)**, **Performance Analytics**, and **Continuous Measurement** into a single, cohesive, premium-designed platform.

## ğŸ¯ Mission Statement

JewelMatrix transforms how organizations operate by bridging the gap between strategic planning and tactical execution. It provides real-time visibility, intelligent automation, and data-driven insights to optimize organizational performance at every level.

---

## ğŸ“‹ Table of Contents

1. [System Architecture Flowchart](#-system-architecture-flowchart)
2. [System Architecture & Technology Stack](#-1-system-architecture--technology-stack)
3. [Security & Governance](#-2-security--governance)
4. [Domain Model & Data Architecture](#-3-domain-model--data-architecture)
5. [The Performance Scoring Engine](#-4-the-performance-scoring-engine)
6. [Service Layer Documentation](#-5-service-layer-documentation)
7. [API Endpoints Reference](#-6-api-endpoints-reference)
8. [Component Architecture](#-7-component-architecture)
9. [Feature Inventory](#-8-feature-inventory)
10. [Database Schema & Collections](#-9-database-schema--collections)
11. [Developer Guide](#-10-developer-guide)
12. [Deployment & DevOps](#-11-deployment--devops)
13. [Performance Benchmarks](#-12-performance-benchmarks)

---

## ğŸ“Š SYSTEM ARCHITECTURE FLOWCHART

### High-Level System Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          JEWELMATRIX SYSTEM ARCHITECTURE                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚   END USERS / EMPLOYEES  â”‚
                            â”‚ (Admin/Manager/Employee) â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                         â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                    â”‚                    â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚   Web Browser   â”‚  â”‚  Mobile Browser â”‚  â”‚  API Clients    â”‚
           â”‚   (Next.js SSR) â”‚  â”‚   (SSR/CSR)     â”‚  â”‚  (3rd party)    â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚                    â”‚                    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                         â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      NEXT.JS APPLICATION LAYER          â”‚
                    â”‚        (Frontend + API Routes)          â”‚
                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
                    â”‚  â”‚ React Server Components (RSC)   â”‚   â”‚
                    â”‚  â”‚ - Dashboard Pages               â”‚   â”‚
                    â”‚  â”‚ - Task Views                    â”‚   â”‚
                    â”‚  â”‚ - OKR Planning                  â”‚   â”‚
                    â”‚  â”‚ - Analytics Views               â”‚   â”‚
                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
                    â”‚  â”‚ API Routes Layer                â”‚   â”‚
                    â”‚  â”‚ - /api/tasks/                   â”‚   â”‚
                    â”‚  â”‚ - /api/okrs/                    â”‚   â”‚
                    â”‚  â”‚ - /api/users/                   â”‚   â”‚
                    â”‚  â”‚ - /api/analytics/               â”‚   â”‚
                    â”‚  â”‚ - /api/admin/                   â”‚   â”‚
                    â”‚  â”‚ - /api/cron/                    â”‚   â”‚
                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
                    â”‚  â”‚ Middleware Layer                â”‚   â”‚
                    â”‚  â”‚ - Authentication (withAuth)     â”‚   â”‚
                    â”‚  â”‚ - Authorization (withAdmin)     â”‚   â”‚
                    â”‚  â”‚ - Input Sanitization            â”‚   â”‚
                    â”‚  â”‚ - Request Validation            â”‚   â”‚
                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                         â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                               â”‚                               â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”
    â”‚  SERVICE LAYER        â”‚   â”‚  FIREBASE ADMIN SDK â”‚   â”‚   EXTERNAL   â”‚
    â”‚  (src/lib/*.ts)       â”‚   â”‚  (Server-side logic)â”‚   â”‚   SERVICES   â”‚
    â”‚                       â”‚   â”‚                     â”‚   â”‚              â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ â”‚ Task Services   â”‚   â”‚   â”‚ â”‚ Admin Auth   â”‚   â”‚   â”‚ â”‚ Email    â”‚ â”‚
    â”‚ â”‚ - taskService   â”‚   â”‚   â”‚ â”‚ Admin DB     â”‚   â”‚   â”‚ â”‚ Service  â”‚ â”‚
    â”‚ â”‚ - enhanced      â”‚   â”‚   â”‚ â”‚              â”‚   â”‚   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â”‚ â”‚   TaskService   â”‚   â”‚   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚              â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚            â”‚               â”‚ â”‚ SMS API  â”‚ â”‚
    â”‚ â”‚ User Services   â”‚   â”‚            â”‚               â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â”‚ â”‚ - userService   â”‚   â”‚            â”‚               â”‚              â”‚
    â”‚ â”‚ - enhanced      â”‚   â”‚            â–¼               â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ â”‚   UserService   â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚ Cloud    â”‚ â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚ FIRESTORE        â”‚   â”‚ â”‚ Storage  â”‚ â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚ (Real-time DB)   â”‚   â”‚ â”‚ (Files)  â”‚ â”‚
    â”‚ â”‚ OKR Services    â”‚   â”‚   â”‚                  â”‚   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â”‚ â”‚ - okrService    â”‚   â”‚   â”‚ Collections:     â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚ â”‚ - kraService    â”‚   â”‚   â”‚ - users          â”‚
    â”‚ â”‚ - kpiService    â”‚   â”‚   â”‚ - tasks          â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚ - objectives     â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚ - keyResults     â”‚
    â”‚ â”‚ Analytics &     â”‚   â”‚   â”‚ - tickets        â”‚
    â”‚ â”‚ Scoring         â”‚   â”‚   â”‚ - kras           â”‚
    â”‚ â”‚ - enhanced      â”‚   â”‚   â”‚ - kpis           â”‚
    â”‚ â”‚   ScoringServiceâ”‚   â”‚   â”‚ - admin_logs     â”‚
    â”‚ â”‚ - analytics     â”‚   â”‚   â”‚ - notifications  â”‚
    â”‚ â”‚   Service       â”‚   â”‚   â”‚ - learning_      â”‚
    â”‚ â”‚ - performance   â”‚   â”‚   â”‚   articles       â”‚
    â”‚ â”‚   Service       â”‚   â”‚   â”‚ - reminders      â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚ - activity_log   â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚ â”‚ Support         â”‚   â”‚
    â”‚ â”‚ Services        â”‚   â”‚
    â”‚ â”‚ - ticketService â”‚   â”‚
    â”‚ â”‚ - learning      â”‚   â”‚
    â”‚ â”‚   HubService    â”‚   â”‚
    â”‚ â”‚ - reminder      â”‚   â”‚
    â”‚ â”‚   Service       â”‚   â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚ â”‚ Admin Services  â”‚   â”‚
    â”‚ â”‚ - adminService  â”‚   â”‚
    â”‚ â”‚ - activity      â”‚   â”‚
    â”‚ â”‚   Logger        â”‚   â”‚
    â”‚ â”‚ - sanitization  â”‚   â”‚
    â”‚ â”‚ - validation    â”‚   â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚ â”‚ Intelligence    â”‚   â”‚
    â”‚ â”‚ Services        â”‚   â”‚
    â”‚ â”‚ - intelligence  â”‚   â”‚
    â”‚ â”‚   Service       â”‚   â”‚
    â”‚ â”‚ - notification  â”‚   â”‚
    â”‚ â”‚   Service       â”‚   â”‚
    â”‚ â”‚ - export        â”‚   â”‚
    â”‚ â”‚   Service       â”‚   â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                    â”‚
         â”‚                    â”‚
         â–¼                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Context Layer   â”‚  â”‚ Firebase Auth      â”‚
    â”‚ (React Context) â”‚  â”‚ - User Auth        â”‚
    â”‚ - AuthContext   â”‚  â”‚ - Session Mgmt     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         DATA FLOW ARCHITECTURE                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                            USER INTERACTION
                                   â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                             â”‚
              â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   Page    â”‚              â”‚  Form Submit    â”‚
              â”‚ Component â”‚              â”‚  Button Click   â”‚
              â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚                             â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚ Event Handler / â”‚
                         â”‚ Form Submit     â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  API Client Call           â”‚
                    â”‚  (authenticatedJsonFetch)  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  HTTP Request + Auth Token â”‚
                    â”‚  â†“                         â”‚
                    â”‚  API Route Handler         â”‚
                    â”‚  (src/app/api/...)         â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Middleware Validation     â”‚
                    â”‚  - Auth Check              â”‚
                    â”‚  - Admin Check             â”‚
                    â”‚  - Input Validation        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Service Layer Processing  â”‚
                    â”‚  - Business Logic          â”‚
                    â”‚  - Database Operations     â”‚
                    â”‚  - Notifications           â”‚
                    â”‚  - Activity Logging        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚                 â”‚                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
         â”‚ Firestore   â”‚   â”‚ Admin SDK   â”‚   â”‚ External   â”‚
         â”‚ Read/Write  â”‚   â”‚ Operations  â”‚   â”‚ Services   â”‚
         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                â”‚                 â”‚                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
         â”‚          Response Aggregation & Formatting        â”‚
         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  JSON Response         â”‚
         â”‚  â†“                     â”‚
         â”‚  HTTP 200/Error Code   â”‚
         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  React Component Receives    â”‚
         â”‚  Response                    â”‚
         â”‚  - Update State              â”‚
         â”‚  - Trigger Re-render         â”‚
         â”‚  - Show Toast/Notification   â”‚
         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  UI Reflects Changes         â”‚
         â”‚  - Update Task Status        â”‚
         â”‚  - Refresh Dashboard         â”‚
         â”‚  - Show Success Message      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Task Lifecycle Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TASK LIFECYCLE & STATE MACHINE                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                            TASK CREATED
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   not_started (Initial) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   assigned (Manager)    â”‚
                    â”‚   (Awaiting Employee)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                      â”‚                      â”‚
      â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
      â”‚ blocked â”‚          â”‚ in_progress  â”‚       â”‚  on_hold   â”‚
      â”‚ (Risk)  â”‚          â”‚ (Working)    â”‚       â”‚ (Paused)   â”‚
      â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                     â”‚
          â”‚                      â–¼                     â”‚
          â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
          â”‚          â”‚ pending_review   â”‚              â”‚
          â”‚          â”‚ (Manager Review) â”‚              â”‚
          â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
          â”‚                   â”‚                        â”‚
          â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
          â”‚      â”‚            â”‚            â”‚           â”‚
          â”‚  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”       â”‚
          â”‚  â”‚revision â”‚  â”‚verify â”‚  â”‚reject  â”‚       â”‚
          â”‚  â”‚requestedâ”‚  â”‚       â”‚  â”‚        â”‚       â”‚
          â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â”‚       â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜       â”‚
          â”‚       â”‚       â”‚       â”‚       â”‚           â”‚
          â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚           â”‚
          â”‚               â”‚               â”‚           â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ completed       â”‚
                 â”‚ (Task Success)  â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ archived        â”‚
                 â”‚ (Historical)    â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PARALLEL STATES:
- cancelled: Can be cancelled at any point
- overdue: Automatic state when dueDate < now
```

### Performance Scoring Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  PERFORMANCE SCORING CALCULATION FLOW                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                      WEEKLY SCORE RECALCULATION
                              â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ Fetch All User Tasks    â”‚
                 â”‚ (Filter by userId)      â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚               â”‚               â”‚
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
         â”‚ Completion â”‚  â”‚ Timeliness â”‚  â”‚ Quality   â”‚
         â”‚ Score      â”‚  â”‚ Score      â”‚  â”‚ Score     â”‚
         â”‚ Calc       â”‚  â”‚ Calc       â”‚  â”‚ Calc      â”‚
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
              â”‚               â”‚             â”‚
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Completed Tasks / Total Tasks            â”‚
         â”‚ (Only where assignedTo.includes(userId)) â”‚
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ On-Time Tasks / Completed Tasks          â”‚
         â”‚ Check: completedAt <= dueDate/finalDate  â”‚
         â”‚ Linear decay for overdue tasks           â”‚
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Revision Penalties Applied               â”‚
         â”‚ -5% per revision on final score          â”‚
         â”‚ Cumulative for multiple revisions        â”‚
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                â”‚                â”‚
         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
         â”‚ KRA      â”‚    â”‚Consistency â”‚   â”‚Weighted  â”‚
         â”‚Alignment â”‚    â”‚Bonus       â”‚   â”‚Intensity â”‚
         â”‚(if KRAs) â”‚    â”‚(90%+velo)  â”‚   â”‚(Priority)â”‚
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
              â”‚                â”‚             â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Overall Score = WA  â”‚
                    â”‚ Completion (30%)    â”‚
                    â”‚ + Timeliness (30%)  â”‚
                    â”‚ + Quality (20%)     â”‚
                    â”‚ + KRA Align (10%)   â”‚
                    â”‚ + Consistency (10%) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Store in DB         â”‚
                    â”‚ - user_scores       â”‚
                    â”‚ - score_history     â”‚
                    â”‚ - timestamp         â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Trigger Events      â”‚
                    â”‚ - Achievement Badge â”‚
                    â”‚ - Notifications     â”‚
                    â”‚ - Dashboard Update  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### OKR Progress Tracking Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      OKR PROGRESS CALCULATION                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

           OBJECTIVE CREATED (Quarterly/Yearly)
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚               â”‚               â”‚
    â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
    â”‚ Add     â”‚   â”‚ Link Tasks â”‚   â”‚ Link    â”‚
    â”‚ Key     â”‚   â”‚ for        â”‚   â”‚ KPIs    â”‚
    â”‚Results  â”‚   â”‚ Execution  â”‚   â”‚ for     â”‚
    â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
        â”‚               â”‚              â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Task Completion Triggers       â”‚
        â”‚ - Task marked completed        â”‚
        â”‚ - Checklist items completed    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Calculate Key Result Progress  â”‚
        â”‚ KR Type Calculation:           â”‚
        â”‚ - Percentage: current/target   â”‚
        â”‚ - Number: count/target         â”‚
        â”‚ - Currency: amount/target      â”‚
        â”‚ - Boolean: achieved/not        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Aggregate KR Progress          â”‚
        â”‚ â†’ Objective Progress (0-100%)  â”‚
        â”‚ Average of all KRs             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Check Completion Milestone     â”‚
        â”‚ - 100% = Completed             â”‚
        â”‚ - Update OKR Status            â”‚
        â”‚ - Record completedAt           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Update Dashboards & Reports    â”‚
        â”‚ - Refresh team dashboards      â”‚
        â”‚ - Update analytics             â”‚
        â”‚ - Send notifications           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Multi-User Task Assignment Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MULTI-ASSIGNEE TASK MANAGEMENT FLOW                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

              TASK CREATED WITH MULTIPLE ASSIGNEES
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ assignedTo: [user1, user2,   â”‚
              â”‚             user3]           â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                â”‚                â”‚
        â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”
        â”‚ User 1  â”‚       â”‚ User 2  â”‚      â”‚ User 3  â”‚
        â”‚ Notifiedâ”‚       â”‚ Notifiedâ”‚      â”‚ Notifiedâ”‚
        â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
            â”‚                â”‚                â”‚
            â”‚                â”‚                â”‚
        â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
        â”‚ Each User Works on Task                    â”‚
        â”‚ (May have different progress)             â”‚
        â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
        â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Individual Completion Tracking            â”‚
        â”‚ - user1_status: in_progress              â”‚
        â”‚ - user2_status: completed                â”‚
        â”‚ - user3_status: pending_review           â”‚
        â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
        â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Task Status Resolution                    â”‚
        â”‚ ONLY when ALL assignees complete:        â”‚
        â”‚ status â†’ completed                       â”‚
        â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
        â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Score Calculation                        â”‚
        â”‚ Each user's score:                       â”‚
        â”‚ - Counted only for their work            â”‚
        â”‚ - No double-counting                     â”‚
        â”‚ - Individual accountability              â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### System Integration & Communication

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 SYSTEM INTEGRATION ARCHITECTURE                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        NOTIFICATION ENGINE                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  Task Completion â†’ NotificationService â†’ Email + In-App Toast       â”‚
â”‚  Task Overdue â†’ NotificationService â†’ Email + Mobile Push           â”‚
â”‚  OKR Updated â†’ NotificationService â†’ Email + Dashboard Alert        â”‚
â”‚  Ticket Resolved â†’ NotificationService â†’ Email + SMS (Optional)     â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       REMINDER SYSTEM                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  Cron Job (Daily/Hourly) â†’ reminderService.processDueReminders()    â”‚
â”‚  â”œâ”€ Check due reminders                                             â”‚
â”‚  â”œâ”€ Format notification content                                     â”‚
â”‚  â”œâ”€ Send via NotificationService                                    â”‚
â”‚  â””â”€ Mark as sent or snooze                                          â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ACTIVITY LOGGING SYSTEM                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  Every Service Operation â†’ activityLogger.log({...})                â”‚
â”‚  â”œâ”€ userId, action, entityType, entityId                           â”‚
â”‚  â”œâ”€ oldValue, newValue, timestamp                                  â”‚
â”‚  â”œâ”€ Store in admin_logs collection                                 â”‚
â”‚  â””â”€ Immutable audit trail                                          â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   INTELLIGENCE SERVICE                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  Real-time Analysis Triggers:                                       â”‚
â”‚  â”œâ”€ Task Analytics: Completion rates, cycle time                   â”‚
â”‚  â”œâ”€ Risk Detection: Overdue patterns, velocity drop                â”‚
â”‚  â”œâ”€ Anomaly Detection: Unusual task patterns                       â”‚
â”‚  â”œâ”€ Predictions: Task at-risk scoring                              â”‚
â”‚  â””â”€ Recommendations: Resource allocation                           â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EXPORT & REPORTING SYSTEM                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  Report Generation Triggers:                                        â”‚
â”‚  â”œâ”€ On-demand: User clicks "Export to PDF"                         â”‚
â”‚  â”œâ”€ Scheduled: Weekly MIS reports via cron                         â”‚
â”‚  â”œâ”€ Format: CSV, PDF, JSON                                         â”‚
â”‚  â””â”€ Storage: Firebase Cloud Storage + Download                     â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Security & Access Control Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AUTHENTICATION & AUTHORIZATION FLOW                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

              USER LOGIN ATTEMPT
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Firebase Auth SDK   â”‚
         â”‚ (Email + Password)  â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Auth Successful?    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              Yes   â”‚    No
                    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º [Reject]
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Fetch User Profile  â”‚
         â”‚ from Firestore      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Get Custom Claims   â”‚
         â”‚ (role, permissions) â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Set Auth Context    â”‚
         â”‚ (React Context)     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
              â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
              â”‚ User Page â”‚
              â”‚ Request   â”‚
              â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ withAuth() Middleware
         â”‚ Check Auth Token    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              Valid â”‚    Invalid
                    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º [401 Unauthorized]
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ withAdmin() (if needed)
         â”‚ Check if admin role â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              Valid â”‚    Invalid
                    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º [403 Forbidden]
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Input Validation    â”‚
         â”‚ - Sanitize inputs   â”‚
         â”‚ - Validate with Zod â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              Valid â”‚    Invalid
                    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º [400 Bad Request]
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Business Logic Checkâ”‚
         â”‚ - Permission check  â”‚
         â”‚ - Resource ownershipâ”‚
         â”‚ - Business rules    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              Valid â”‚    Invalid
                    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º [403 Forbidden]
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Execute Operation   â”‚
         â”‚ - Update Firestore  â”‚
         â”‚ - Log Activity      â”‚
         â”‚ - Trigger Events    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Return Success      â”‚
         â”‚ { success: true }   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—ï¸ 1. System Architecture & Technology Stack


JewelMatrix is built as a robust, serverless application utilizing the latest industry standards for speed, security, and developer productivity.

### ğŸ¨ Frontend Layer
*   **Framework**: **Next.js 16 (App Router)** utilizing React Server Components (RSC) for optimal performance, zero-JS where possible.
*   **UI System**: **Radix UI** primitives powered by **Shadcn/UI**, ensuring accessible, standardized, and premium-feel components with full keyboard navigation.
*   **Styling**: **Tailwind CSS** implementing a "Deep Jewel" enterprise design language with glassmorphism, smooth transitions, and responsive typography.
*   **Icons**: **Lucide React** for consistent, high-quality iconography across 2000+ icons.
*   **Visualization**: **Recharts** for real-time analytics, trend detection, performance tracking, and interactive dashboards.
*   **Form Handling**: **React Hook Form** with **Zod** schema validation for type-safe forms with zero runtime overhead.
*   **Animations**: Custom Tailwind animations (fade-in, slide-up, slide-down, scale-in, pulse-slow) for premium motion design.

### â˜ï¸ Backend & Infrastructure
*   **Cloud Provider**: **Firebase (Serverless Architecture)** for zero-maintenance infrastructure.
*   **Database**: **Firestore (NoSQL)** optimized for low-latency read operations, real-time synchronization, and complex queries.
*   **Authentication**: **Firebase Auth** with role-based custom claims, multi-factor authentication support, and OAuth integration.
*   **Server-Side Logic**: **Next.js API Routes** executing via the **Firebase Admin SDK** to ensure secure, rule-bypassing administrative operations.
*   **Storage**: **Firebase Cloud Storage** for task attachments, user profile pictures, SOP documents, and exported reports.
*   **Real-time Features**: Firestore listeners for live task updates, notifications, and collaborative features.

### ğŸ§  Intelligence Layer
*   **Background Services**: Located in `src/lib/server`, these handle heavy-lifting operations:
    *   **Chronic Overdue Detection**: Pattern analysis to identify habitual delayers and predict task risks.
    *   **Risk Prediction Engine**: AI-driven task risk assessment based on velocity, priority, and team capacity.
    *   **Automated Score Recalculation**: Weekly performance score aggregation with conflict prevention.
    *   **Reminder Processing**: Scheduled notifications for pending work, overdue tasks, and upcoming deadlines.
    *   **Analytics Aggregation**: Real-time computation of dashboards, reports, and performance metrics.
*   **Cron Jobs**: Serverless scheduled tasks via Firebase Cloud Functions for maintenance and automation.
*   **Notification Engine**: Multi-channel notifications (in-app, email) with preference-based delivery.

### ğŸ› ï¸ Development Stack
*   **Language**: **TypeScript** with strict mode enabled for type safety and compile-time error detection.
*   **Package Manager**: **npm** with lock-file for reproducible builds.
*   **Testing**: **Jest** for unit testing with watch mode and coverage reporting.
*   **Linting**: **ESLint** with Next.js configuration for code quality.
*   **Type Checking**: Strict TypeScript compilation with no implicit any.
*   **Git**: Version control with conventional commit practices.

---

## ğŸ›¡ï¸ 2. Security & Governance

JewelMatrix implements a **Zero-Trust Security Model** at the data layer combined with flexible administrative oversight.

### Access Control (RBAC)
*   **Administrator**: 
    - Full system lifecycle management and user provisioning.
    - Organizational health visibility and system configuration.
    - Can perform any action on any resource.
    - Access to admin dashboards, audit logs, and system health.
*   **Manager**: 
    - Departmental oversight and team management.
    - Task delegation and performance review rights.
    - Objective and KRA planning and alignment.
    - View team analytics and performance metrics.
*   **Employee**: 
    - Personal workspace focus with task execution.
    - Ticket raising and support requests.
    - Personal OKR tracking and KRA management.
    - Limited visibility to team information.

### Security Implementation
*   **Firestore Rules**: Rigorous `firestore.rules` preventing unauthorized cross-tenant or cross-user data access with cascading permissions.
*   **Server-Side Execution**: Sensitive operations (password resets, performance edits, user creation) strictly handled by server-side services (`adminAuth`, `adminDb`) to prevent client-side tampering.
*   **Audit Logging**: Every administrative action captured in `admin_logs` collection with permanent timestamp, user trace, and change delta.
*   **Input Validation**: Comprehensive sanitization of user inputs via `sanitize.ts` service with HTML, URL, and JSON sanitization.
*   **Authentication Middleware**: `withAuth()` and `withAdmin()` middleware for all API routes ensuring proper authorization.
*   **CORS & CSRF**: Proper handling of cross-origin requests and CSRF tokens for state-changing operations.

### Data Privacy
*   **Encryption**: Firestore data encrypted at rest and in transit via SSL/TLS.
*   **Data Minimization**: Only necessary user data collected and stored.
*   **Right to Deletion**: Automated data deletion on user account removal.

---

## ğŸ—ºï¸ 3. Domain Model & Data Architecture

The system operates on an interconnected graph of entities that link strategy to execution, creating a unified ecosystem.

### âœ… Execution Layer (Task Management)
*   **Tasks**: Atomic work units with 10-state life cycles:
    - `not_started` â” `assigned` â” `in_progress` â” `pending_review` â” `completed`
    - Alternative paths: `blocked`, `on_hold`, `cancelled`, `revision_requested`, `overdue`
    - Features: priority levels, estimated hours, actual hours tracking, multiple assignees.
*   **Checklists**: Granular sub-tasks with independent completion tracking.
    - Each checklist item is trackable with progress percentage.
    - Completion of all items triggers task readiness for review.
*   **Revisions**: Quality control mechanism allowing managers to reject work with mandatory feedback.
    - Captures revision reason, requested changes, and resolution date.
    - Prevents score calculation until resolved.
*   **Task Extensions**: Allows deadline extension with approval workflow for overdue tasks.
*   **Task Templates**: Reusable task definitions with preset checklists and assignments.
*   **Bulk Operations**: Batch create, update, and assign tasks via CSV import.

### ğŸ¯ Strategy Layer (OKRs)
*   **Objectives**: High-level qualitative goals (e.g., "Scale Infrastructure to 1M Users").
    - Owned by individuals or teams with specified timeframes (quarterly/yearly).
    - Contain multiple Key Results for measurement.
    - Can be linked to tasks and KPIs for traceability.
*   **Key Results (KRs)**: Quantifiable metrics linked to objectives.
    - Support multiple types: percentage, number, currency, boolean.
    - Include current value, target value, and progress calculation.
*   **KRAs (Key Result Areas)**: Job-specific domains of responsibility assigned to employees.
    - Recurring metrics tied to organizational goals.
    - Support daily, weekly, fortnightly, or monthly cadence.
    - Can be rolled up to team and organizational levels.
*   **KPIs**: Recurring weekly metrics tracking performance against KRA targets.
    - Individual KPIs roll up to team KPIs.
    - Historical trend tracking for performance analysis.
*   **OKR Progress**: Automated calculation based on linked task completion and KPI achievement.

### ğŸ¢ Organizational Layer
*   **Departments**: Structural units for budget, reporting, and high-level organization.
    - Can have multiple teams within each department.
    - Department-level performance aggregation.
*   **Teams**: Agile groups where daily tactical coordination happens.
    - Contains members with defined roles.
    - Team lead designation for task delegation.
    - Team-level performance metrics and OKR tracking.
*   **User Profiles**: Rich data including:
    - Employee IDs, email, phone, department/team assignment.
    - Reporting hierarchies and manager designation.
    - Performance history, scores, and achievements.
    - Skill tags and competency areas.
    - Custom role assignments and permissions.
*   **Roles & Permissions**: 
    - System roles (admin, manager, employee) with fixed permissions.
    - Custom roles creatable by admins with granular permission assignment.

### ğŸ“‹ Support & Operations Layer
*   **Tickets**: Service desk requests for HR, IT, and administrative support.
    - Types: office_cleaning, stationery, purchase_request, repair_maintenance, hr_helpdesk, it_support, accounts_admin, general_query.
    - Status workflow: open â” in_progress â” resolved â” closed.
    - Private comment threads for internal discussion.
    - Resolution tracking with knowledge base integration.
*   **Learning Hub**: SOP and documentation repository.
    - Wiki-style articles with categorization and tagging.
    - Search functionality with relevance ranking.
    - "Helpful" feedback loop for curation.
*   **Activity Logs**: Immutable record of all system changes.
    - Timestamp, user, action, entity, and change delta.
    - Queryable by time range, user, entity type.

### ğŸ“Š Analytics & Reporting Layer
*   **Dashboard Stats**: Real-time aggregated metrics for personalized dashboards.
*   **Task Analytics**: Completion rates, timeliness, and cycle time analysis.
*   **Performance Reports**: Team and organizational performance summaries.
*   **KPI Analytics**: Real-time KPI tracking with trend analysis.
*   **Admin Analytics**: System-wide health metrics and user statistics.

---

## ğŸ“ˆ 4. The Performance Scoring Engine

The heart of JewelMatrix is its objective, real-time **Enhanced Scoring Service** (`enhancedScoringService.ts`) implemented in [src/lib/enhancedScoringService.ts](src/lib/enhancedScoringService.ts).

### Scoring Methodology

1.  **Weighted Intensity**: Tasks carry points based on Priority.
    - Normal: 1x weight
    - High: 2x weight
    - Critical: 4x weight
    - Point accumulation for completed tasks.

2.  **Completion Score (0-100)**:
    - Completed Tasks / Total Tasks assigned to employee.
    - Only counts tasks where employee is in assignedTo array.
    - Prevents double-counting across multiple assignees.

3.  **Timeliness Score (0-100)**:
    - On-Time Completions / Total Completed Tasks.
    - Uses `completedAt` timestamp if available.
    - Respects `finalTargetDate` if extension was approved.
    - Linear decay for overdue tasks (penalty per hour overdue).

4.  **Quality Factor**:
    - Base score adjusted for revisions by managers.
    - Fixed percentage penalty per revision (default 5%).
    - Cumulative penalties for multiple revisions.

5.  **KRA Alignment Score (0-100)**:
    - Measures how well completed tasks align with assigned KRAs.
    - Calculates actual vs. planned contribution.

6.  **Consistency Bonus**:
    - Employees maintaining 90%+ velocity over multiple weeks receive cumulative health bonuses.
    - Bonus accrual based on consecutive weeks of high performance.

### Score Recalculation Triggers
*   Task creation, completion, or deletion.
*   Priority changes on active tasks.
*   Task reassignment between employees.
*   Backdated task completion.
*   Manual administrator recalculation.

### Employee-Wise Calculation Guarantee
*   Strict filtering ensures no cross-employee score contamination.
*   Aggregation at team/department level uses individual scores.
*   Historical score snapshots prevent retroactive manipulation.

---

## ğŸ”§ 5. Service Layer Documentation

JewelMatrix provides a comprehensive service layer with 40+ specialized services handling different domains.

### Core Services

#### Task Management
*   **[taskService.ts](src/lib/taskService.ts)**: Basic CRUD operations for tasks, checklist management, task stats, and activity tracking.
*   **[enhancedTaskService.ts](src/lib/enhancedTaskService.ts)**: Wraps taskService with full business rule enforcement, status validation, and workflow management.
*   **[taskBusinessRules.ts](src/lib/taskBusinessRules.ts)**: Defines valid state transitions, business rule validations, and extension logic.
*   **[taskUpdateService.ts](src/lib/taskUpdateService.ts)**: Handles task updates with change tracking and event emission.
*   **[bulkTaskService.ts](src/lib/bulkTaskService.ts)**: CSV import/export and bulk operations on multiple tasks.

#### User Management
*   **[userService.ts](src/lib/userService.ts)**: User CRUD, team assignment, and role management.
*   **[enhancedUserService.ts](src/lib/enhancedUserService.ts)**: Extended user operations including department management and bulk user operations.
*   **[authService.ts](src/lib/authService.ts)**: Authentication flow management, session handling, and auth state.
*   **[authMiddleware.ts](src/lib/authMiddleware.ts)**: Middleware for protecting API routes with `withAuth()` and `withAdmin()` wrappers.

#### OKR & Strategy
*   **[okrService.ts](src/lib/okrService.ts)**: Objectives and Key Results CRUD with alignment calculations and progress tracking.
*   **[kraService.ts](src/lib/kraService.ts)**: Key Result Areas management with automation and scheduling.
*   **[kpiService.ts](src/lib/kpiService.ts)**: KPI creation, tracking, and weekly aggregation.
*   **[kraAutomation.ts](src/lib/kraAutomation.ts)**: Automated KRA calculations and scheduling for recurring metrics.

#### Performance & Analytics
*   **[enhancedScoringService.ts](src/lib/enhancedScoringService.ts)**: Enterprise-grade performance scoring with employee-wise calculations.
*   **[analyticsService.ts](src/lib/analyticsService.ts)**: Dashboard stats, task analytics, KRA analytics, and admin dashboard analytics.
*   **[performanceService.ts](src/lib/performanceService.ts)**: Performance metric aggregation and trend analysis.
*   **[reportService.ts](src/lib/reportService.ts)**: Report generation including MIS reports and performance summaries.

#### Support & Operations
*   **[ticketService.ts](src/lib/ticketService.ts)**: Ticket CRUD, status management, and resolution tracking.
*   **[enhancedTicketService.ts](src/lib/enhancedTicketService.ts)**: Advanced ticket operations with SLA tracking and escalation.
*   **[learningService.ts](src/lib/learningService.ts)**: Learning hub article management and FAQ handling.
*   **[learningHubService.ts](src/lib/learningHubService.ts)**: Enhanced learning hub with categorization and search.

#### Infrastructure & Utilities
*   **[notificationService.ts](src/lib/notificationService.ts)**: Multi-channel notifications (in-app, email) with preferences.
*   **[reminderService.ts](src/lib/reminderService.ts)**: Reminder creation, snoozing, and automated delivery.
*   **[intelligenceService.ts](src/lib/intelligenceService.ts)**: AI-driven insights, risk prediction, and anomaly detection.
*   **[exportService.ts](src/lib/exportService.ts)**: CSV/PDF export functionality for reports and data dumps.
*   **[pdfExportService.ts](src/lib/pdfExportService.ts)**: PDF generation for performance reports and documentation.

#### Business & Growth
*   **[crmService.ts](src/lib/crmService.ts)**: Customer management, portfolio tracking, and relationship analytics.
*   **[marketingService.ts](src/lib/marketingService.ts)**: Campaign tracking, lead analytics, and channel performance metrics.
*   **[salesService.ts](src/lib/salesService.ts)**: Sales pipeline management, deal tracking, and revenue forecasting.
*   **[staffService.ts](src/lib/staffService.ts)**: Employee productivity tracking, attendance, and performance metrics.

#### Admin & System
*   **[adminService.ts](src/lib/adminService.ts)**: System health checks, settings management, and admin utilities.
*   **[activityLogger.ts](src/lib/activityLogger.ts)**: Immutable audit trail logging for compliance.
*   **[sanitize.ts](src/lib/sanitize.ts)**: Comprehensive input sanitization (HTML, URL, JSON, form data).
*   **[validation.ts](src/lib/validation.ts)**: Schema validation using Zod for type safety.

#### Firebase Integrations
*   **[firebase.ts](src/lib/firebase.ts)**: Client-side Firebase configuration and initialization.
*   **[firebase-admin.ts](src/lib/firebase-admin.ts)**: Server-side Admin SDK setup with service account authentication.

---

## ğŸŒ 6. API Endpoints Reference

JewelMatrix exposes a comprehensive REST API following Next.js App Router conventions.

### Task Endpoints

**GET/POST `api/tasks/`**
- List all tasks or create a new task
- Query params: `userId`, `status`, `priority`, `sortBy`
- Response: Task list with pagination metadata

**GET/PUT/DELETE `api/tasks/[taskId]/`**
- Get, update, or delete a specific task
- Returns full task object with nested checklist items

**POST `api/tasks/[taskId]/verify`**
- Verify a completed task or request revision
- Body: `{ status: 'verified' | 'rejected', reason?: string }`
- Returns verification result with feedback

**POST `api/tasks/bulk`**
- Bulk create tasks from CSV
- Body: FormData with CSV file
- Returns operation ID for tracking

**GET `api/tasks/stats/`**
- Get task statistics (completion rate, timeliness, etc.)
- Query params: `userId`, `departmentId`
- Returns TaskStats object

**POST `api/tasks/[taskId]/updates`**
- Track task status updates
- Body: `{ status, reason, completedAt }`
- Returns update confirmation

### User Endpoints

**GET/POST `api/users/`**
- List all users or create new user
- Query params: `departmentId`, `teamId`, `role`
- Response: User list with pagination

**GET/PUT/DELETE `api/users/[userId]/`**
- Get, update, or delete user profile
- Returns full user object with permissions

**POST `api/users/[userId]/assign-team`**
- Assign user to team
- Body: `{ teamId }`

### OKR Endpoints

**GET/POST `api/okrs/`**
- List objectives or create new objective
- Query params: `status`, `timeframe`, `ownerId`
- Response: Objective list with key results

**GET/PUT/DELETE `api/okrs/[objectiveId]/`**
- Get, update, or delete objective
- Returns full objective with KR details

**POST `api/okrs/[objectiveId]/key-results`**
- Add key result to objective
- Body: KeyResult data

**GET `api/okrs/[objectiveId]/progress`**
- Get OKR progress calculation
- Returns progress percentage and status

### Ticket Endpoints

**GET/POST `api/tickets/`**
- List tickets or create new ticket
- Query params: `status`, `priority`, `assignedTo`
- Response: Ticket list with solutions

**GET/PUT/DELETE `api/tickets/[ticketId]/`**
- Get, update, or delete ticket
- Returns full ticket with comments and solutions

**POST `api/tickets/[ticketId]/solutions`**
- Add solution to ticket
- Body: `{ solutionText }`

### Analytics Endpoints

**GET `api/analytics/dashboard`**
- Get dashboard statistics for user
- Returns: DashboardStats with real-time metrics

**GET `api/analytics/tasks`**
- Get task analytics (completion, timeliness, cycles)
- Returns: TaskAnalytics object

**GET `api/analytics/kra`**
- Get KRA analytics with trends
- Returns: KRAAnalytics with historical data

**GET `api/analytics/admin`**
- Get admin dashboard analytics (admin only)
- Returns: System-wide health metrics

### Performance Endpoints

**GET `api/performance/scores`**
- Get performance scores for users
- Query params: `userId`, `teamId`, `periodStart`, `periodEnd`
- Returns: ScoreResult array

**POST `api/performance/recalculate`**
- Trigger score recalculation (admin only)
- Body: `{ userId?, taskId?, reason }`

### Admin Endpoints

**GET `api/admin/system-health`**
- Get system health metrics
- Returns: CPU, memory, error rates, user counts

**POST `api/admin/users`**
- Bulk user operations
- Body: `{ action, userIds, data }`

**GET `api/admin/activity-log`**
- Get activity audit trail
- Query params: `userId`, `action`, `startDate`, `endDate`

### Cron Endpoints

**POST `api/cron/score-recalculation`**
- Triggered weekly to recalculate all user scores
- Ensures performance metrics stay current

**POST `api/cron/reminder-processing`**
- Process due reminders and send notifications
- Can be triggered manually or via Cloud Scheduler

---

## ğŸ¨ 7. Component Architecture

JewelMatrix uses a well-organized component hierarchy with Shadcn/UI foundations.

### Directory Structure
```
src/components/
â”œâ”€â”€ ui/                          # Shadcn/UI base components
â”‚   â”œâ”€â”€ button.tsx
â”‚   â”œâ”€â”€ card.tsx
â”‚   â”œâ”€â”€ dialog.tsx
â”‚   â”œâ”€â”€ dropdown-menu.tsx
â”‚   â”œâ”€â”€ form.tsx
â”‚   â”œâ”€â”€ input.tsx
â”‚   â”œâ”€â”€ select.tsx
â”‚   â”œâ”€â”€ tabs.tsx
â”‚   â””â”€â”€ toast.tsx
â”œâ”€â”€ admin/                       # Admin dashboard components
â”‚   â”œâ”€â”€ AdminOperationalActions.tsx
â”‚   â”œâ”€â”€ AdminVerificationQueue.tsx
â”‚   â”œâ”€â”€ ExtensionRequestQueue.tsx
â”‚   â”œâ”€â”€ HolidayManager.tsx
â”‚   â”œâ”€â”€ PerformanceAnalytics.tsx
â”‚   â”œâ”€â”€ PerformanceTrends.tsx
â”‚   â””â”€â”€ ReportGenerator.tsx
â”œâ”€â”€ common/                      # Reusable shared components
â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”œâ”€â”€ Sidebar.tsx
â”‚   â”œâ”€â”€ TaskCard.tsx
â”‚   â”œâ”€â”€ UserAvatar.tsx
â”‚   â””â”€â”€ StatusBadge.tsx
â”œâ”€â”€ features/                    # Feature-specific components
â”‚   â”œâ”€â”€ Dashboard/
â”‚   â”œâ”€â”€ TaskManagement/
â”‚   â”œâ”€â”€ OKRPlanning/
â”‚   â”œâ”€â”€ TicketSystem/
â”‚   â””â”€â”€ LearningHub/
â”œâ”€â”€ layout/                      # Layout wrapper components
â”‚   â”œâ”€â”€ MainLayout.tsx
â”‚   â””â”€â”€ DashboardLayout.tsx
â”œâ”€â”€ AdminLayout.tsx              # Root admin layout
â””â”€â”€ index.ts                     # Component exports
```

### Component Best Practices
*   All interactive components use Radix UI primitives via Shadcn/UI.
*   Forms use React Hook Form with Zod validation.
*   Server Components preferred for data fetching.
*   Client components use "use client" directive only when necessary.
*   Styling through Tailwind CSS utility classes.
*   Custom hooks in `src/hooks/` for reusable logic.
*   Prop drilling minimized using React Context (`src/contexts/`).

---

## ğŸš€ 8. Feature Inventory

### ğŸ–¥ï¸ Mission Control (Dashboard)
*   **Personalization**: Context-aware greeting, dynamic task priority lists.
*   **Quick Actions**: Standardized forms for "Assign New Task", "Add New Person", "Create Objective".
*   **Status Cards**: Real-time counters for pending work, overdue tasks, open tickets, achievement metrics.
*   **Performance Widgets**: Score display, trend graphs, consistency indicators.
*   **Analytics Panels**: Task completion rates, team capacity, KPI progress.

### ğŸŸï¸ Ticket System (Operational Desk)
*   **Ticket Creation**: Multiple request types (HR, IT, Admin, Operations).
*   **Status Tracking**: Open â†’ In Progress â†’ Resolved â†’ Closed workflow.
*   **Private Comments**: Internal discussion thread on each ticket.
*   **Solution Management**: Multiple solutions per ticket with acceptance tracking.
*   **SLA Monitoring**: Due date tracking with escalation alerts.
*   **Knowledge Base Integration**: One-click "Resolve to Article" for FAQ expansion.

### ğŸ“š Learning Hub & SOPs
*   **Article Repository**: Wiki-style documentation with rich text editor.
*   **Categorization & Tags**: Organize articles by department, topic, or type.
*   **Search**: Full-text search with relevance ranking and autocomplete.
*   **Helpful Voting**: Community feedback to surface high-impact articles.
*   **View Tracking**: Measure article engagement and identify documentation gaps.
*   **Version History**: Track article edits and maintain previous versions.

### ğŸ‘¥ People Management
*   **User CRUD**: Full lifecycle management with email, phone, and metadata.
*   **Team Composition**: Drag-and-drop team building, role assignment.
*   **Department Organization**: Hierarchical structure with reporting lines.
*   **Custom Roles**: Admin-defined roles with granular permission assignment.
*   **Performance History**: Historical score tracking, achievement badges.
*   **Bulk Import**: CSV upload for mass user provisioning.
*   **Enhanced Profiles**: Detailed personal information including Date of Birth, Aadhar, and PAN.
*   **Document Management**: Secure upload and storage of KYC documents and personal records.

### ğŸ“Š Analytics & Reporting
*   **Personal Dashboard**: Individual task and OKR progress tracking.
*   **Team Analytics**: Aggregated metrics for team leaders.
*   **Department Analytics**: High-level organizational metrics.
*   **System Admin Dashboard**: User counts, error rates, system health.
*   **Custom Reports**: MIS reports, performance summaries, trend analysis.
*   **Export Capabilities**: PDF and CSV export for external tools.

### ğŸ¯ OKR & Strategy Planning
*   **Objective Creation**: Quarterly and yearly OKR cycles with inheritance.
*   **Key Result Tracking**: Multiple KR types (%, #, $, boolean).
*   **Alignment**: Link tasks and KPIs to OKRs for traceability.
*   **Progress Calculation**: Automated OKR progress based on linked work.
*   **Review Workflow**: Formal OKR review cycle with comment threads.
*   **Historical Archive**: Keep past OKR cycles for trend analysis.

### âœ… Task Management
*   **Task Creation**: Quick entry with priority, assignee, due date, checklist.
*   **Task Templates**: Save and reuse task definitions across projects.
*   **Bulk Import**: CSV upload for batch task creation.
*   **Status Workflow**: 10-state lifecycle with validation rules.
*   **Checklist Tracking**: Sub-tasks with independent completion.
*   **Extension Requests**: Deadline extension with manager approval.
*   **Activity Timeline**: Full history of task changes.
*   **Verification Queue**: Manager review before final completion.

### ğŸ“ˆ KRA & KPI Management
*   **KRA Definition**: Job-specific result areas with metrics.
*   **Recurring KPIs**: Weekly metrics aggregation for each KRA.
*   **Automation**: Automatic KPI calculation for eligible KRAs.
*   **Trend Analysis**: Historical KPI performance tracking.
*   **Goal Setting**: Target definition with achievement tracking.

---

## ğŸ“Š 9. Database Schema & Collections

### Collections Overview

#### users
```
{
  id: string
  email: string
  name: string
  displayName: string
  photoURL?: string
  role: 'admin' | 'manager' | 'employee'
  customRoles?: string[]
  departmentId: string
  teamId?: string
  managerId?: string
  status: 'active' | 'inactive'
  createdAt: timestamp
  updatedAt: timestamp
  performanceScore?: number
  lastActiveAt?: timestamp
}
```

#### tasks
```
{
  id: string
  title: string
  description: string
  priority: 'low' | 'medium' | 'high' | 'critical'
  status: TaskStatus
  assignedTo: string[]
  createdBy: string
  dueDate: date
  finalTargetDate?: date
  startDate?: date
  completedAt?: date
  estimatedHours?: number
  actualHours?: number
  checklist?: ChecklistItem[]
  kraIds?: string[]
  revisions?: Revision[]
  linkedObjectiveId?: string
  createdAt: timestamp
  updatedAt: timestamp
}
```

#### objectives
```
{
  id: string
  title: string
  description: string
  ownerId: string
  ownerName: string
  teamId?: string
  teamName?: string
  timeframe: 'quarterly' | 'yearly'
  startDate: date
  endDate: date
  quarter?: number
  year: number
  status: OKRStatus
  progress: number (0-100)
  keyResultIds: string[]
  linkedTaskIds?: string[]
  linkedKPIIds?: string[]
  createdBy: string
  createdByName: string
  createdAt: timestamp
  updatedAt: timestamp
  completedAt?: date
}
```

#### keyResults
```
{
  id: string
  objectiveId: string
  title: string
  description: string
  type: 'percentage' | 'number' | 'currency' | 'boolean'
  startValue: number
  currentValue: number
  targetValue: number
  unit: string
  progress: number (0-100)
  owner: string
  createdAt: timestamp
  updatedAt: timestamp
}
```

#### tickets
```
{
  id: string
  ticketNumber: string
  subject: string
  description: string
  requesterId: string
  requesterName: string
  requesterEmail: string
  requestType: TicketRequestType
  priority: Priority
  departmentId?: string
  assignedTo?: string
  assignedToName?: string
  assignedAt?: date
  dueDate: date
  status: TicketStatus
  solutions: TicketSolution[]
  resolvedBy?: string
  resolvedByName?: string
  resolvedAt?: date
  attachments?: string[]
  tags?: string[]
  createdAt: timestamp
  updatedAt: timestamp
}
```

#### admin_logs
```
{
  id: string
  adminId: string
  adminName: string
  action: string
  entityType: string
  entityId: string
  oldValue?: any
  newValue?: any
  timestamp: timestamp
  ipAddress?: string
  userAgent?: string
}
```

#### learning_articles
```
{
  id: string
  title: string
  content: string
  category: string
  tags: string[]
  author: string
  authorName: string
  helpfulCount: number
  unhelpfulCount: number
  viewCount: number
  createdAt: timestamp
  updatedAt: timestamp
  publishedAt?: date
}
```

#### notifications
```
{
  id: string
  userId: string
  type: string
  title: string
  message: string
  data?: any
  read: boolean
  actionUrl?: string
  createdAt: timestamp
  expiresAt?: date
}
```

---

## ğŸ§‘â€ğŸ’» 10. Developer Guide

### Environment Setup

#### Prerequisites
*   **Node.js**: Version 20.x or higher (LTS recommended).
*   **npm**: Version 10.x or higher.
*   **Firebase CLI**: Installed globally for rule deployment.
*   **Git**: For version control.

#### Step 1: Clone & Install
```bash
git clone <repository-url>
cd jewelmatrix
npm install
```

#### Step 2: Configure Environment Variables
Create `.env.local` in the project root:
```env
# Firebase Client Config (Public)
NEXT_PUBLIC_FIREBASE_API_KEY=<your-api-key>
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=<your-auth-domain>
NEXT_PUBLIC_FIREBASE_PROJECT_ID=<your-project-id>
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=<your-storage-bucket>
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=<your-sender-id>
NEXT_PUBLIC_FIREBASE_APP_ID=<your-app-id>

# Firebase Admin Config (Server-side only)
FIREBASE_PRIVATE_KEY="<your-service-account-private-key>"
FIREBASE_CLIENT_EMAIL="<your-service-account-email>"
FIREBASE_PROJECT_ID=<your-project-id>

# Application Config
NEXT_PUBLIC_APP_URL=http://localhost:3000
NODE_ENV=development
```

#### Step 3: Start Development Server
```bash
npm run dev
```
Open [http://localhost:3000](http://localhost:3000) in your browser.

### Development Standards

#### TypeScript
*   Strict mode enabled: `noImplicitAny: false` but prefer explicit types.
*   No unused variables or imports.
*   Use interfaces for data structures, types for unions and literals.
*   Define types in `src/types/index.ts` for re-usable types.

#### Component Development
*   Always use Shadcn/UI components from `src/components/ui`.
*   Server Components by default, Client Components only when needed.
*   Prop drilling should be minimal; use Context for shared state.
*   Extract custom hooks to `src/hooks/` for reusability.

#### API Routes
*   All new API routes must use `withAuth()` or `withAdmin()` from `src/lib/authMiddleware`.
*   Validate input using Zod schemas from `src/lib/validation.ts`.
*   Use `sanitize.ts` functions for user input sanitization.
*   Return consistent response format: `{ success: boolean, data?: any, error?: string }`.

#### Service Layer
*   Create service classes or exported functions in `src/lib/`.
*   Use Firebase Admin SDK for server-side operations.
*   Use client SDK (src/lib/firebase.ts) for browser operations.
*   Document public methods with JSDoc comments.

#### Styling
*   Use Tailwind CSS utility classes; avoid custom CSS where possible.
*   Follow dark mode conventions with `dark:` prefix.
*   Use color tokens from theme: `bg-primary`, `text-foreground`, etc.
*   Custom animations defined in `tailwind.config.js`.

#### Testing
```bash
npm run test              # Run tests once
npm run test:watch       # Run tests in watch mode
npm run test:coverage    # Generate coverage report
```

### Build & Stability Standards

To ensure 100% project stability, all changes must pass strict TypeScript compilation and production build checks.

#### Verification Commands
```bash
# Full stability check: TypeScript + Production Build
npx tsc --strict --noUnusedLocals --noUnusedParameters --noImplicitReturns --noEmit && npm run build
```

#### Standards
*   **Zero-Error Tolerance**: `tsc` must return 0 errors before any merge.
*   **Import Optimization**: Remove all unused imports including icons and types.
*   **Property Safety**: Use optional chaining (`?.`) for all potentially undefined properties from services.
*   **Layout Consistency**: Use `ReactNode` (from 'react') for all `children` props in layouts and guards.

### Git Workflow
*   Use conventional commits: `feat:`, `fix:`, `docs:`, `chore:`, `refactor:`.
*   Branch naming: `feature/task-description`, `bugfix/issue-description`.
*   Create pull requests for code review before merging to main.

### Code Examples

#### Creating a New Task Service Function
```typescript
// src/lib/taskService.ts
export async function archiveTask(taskId: string): Promise<void> {
    await adminDb.collection('tasks').doc(taskId).update({
        status: 'archived',
        archivedAt: new Date(),
        updatedAt: new Date(),
    });
    
    // Log the action
    await activityLogger.log({
        userId: currentUserId,
        action: 'task_archived',
        entityType: 'task',
        entityId: taskId,
    });
}
```

#### Creating a New API Route
```typescript
// src/app/api/tasks/archive/route.ts
import { withAdmin } from '@/lib/authMiddleware';
import { archiveTask } from '@/lib/taskService';
import { validateData } from '@/lib/validation';
import { z } from 'zod';

export const POST = withAdmin(async (req, context) => {
    const schema = z.object({ taskId: z.string() });
    const parsed = validateData(schema, await req.json());
    
    if (!parsed.success) {
        return Response.json({ error: parsed.errors }, { status: 400 });
    }
    
    await archiveTask(parsed.data.taskId);
    return Response.json({ success: true });
});
```

#### Creating a New Component
```typescript
// src/components/features/TaskBoard/TaskCard.tsx
'use client';

import { Task } from '@/types';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

interface TaskCardProps {
    task: Task;
    onSelect: (taskId: string) => void;
}

export function TaskCard({ task, onSelect }: TaskCardProps) {
    return (
        <Card className="cursor-pointer hover:shadow-lg transition-shadow" onClick={() => onSelect(task.id)}>
            <CardHeader>
                <CardTitle className="text-lg">{task.title}</CardTitle>
            </CardHeader>
            <CardContent>
                <Badge variant={task.priority === 'critical' ? 'destructive' : 'secondary'}>
                    {task.priority}
                </Badge>
            </CardContent>
        </Card>
    );
}
```

---

## ğŸš€ 11. Deployment & DevOps

### Build & Production

#### Build Process
```bash
npm run build              # Compile Next.js application
npm run typecheck         # Verify TypeScript
npm run lint              # Run ESLint
npm start                 # Start production server
```

### Deployment to Vercel

1. **Connect Repository**:
   ```bash
   vercel login
   vercel link
   ```

2. **Set Environment Variables**:
   - Add all `.env.local` variables to Vercel project settings.
   - Separate public and secret variables.

3. **Deploy**:
   ```bash
   vercel --prod
   ```

### Firestore Rules Deployment
```bash
firebase login
firebase deploy --only firestore:rules
```

### Firebase Cloud Functions (Cron Jobs)
Deploy scheduled tasks via Firebase Console â†’ Cloud Functions â†’ Create Function.

Examples:
- Daily score recalculation
- Weekly reminder processing
- Monthly report generation

---

## âš¡ 12. Performance Benchmarks

### Expected Performance Targets
*   **First Contentful Paint (FCP)**: < 1.5 seconds
*   **Largest Contentful Paint (LCP)**: < 2.5 seconds
*   **Cumulative Layout Shift (CLS)**: < 0.1
*   **Task Completion Response**: < 100ms
*   **Dashboard Load**: < 2 seconds
*   **Search Query**: < 500ms

### Optimization Strategies
*   Server-Side Rendering (SSR) for initial page load.
*   Image optimization via Next.js Image component.
*   Code splitting via dynamic imports.
*   Firestore query optimization with proper indexing.
*   Caching strategies for frequently accessed data.
*   CDN delivery for static assets.

---

## ğŸ“š Additional Resources

### Documentation Files
*   [Next.js Documentation](https://nextjs.org/docs)
*   [Firebase Documentation](https://firebase.google.com/docs)
*   [Tailwind CSS](https://tailwindcss.com)
*   [Radix UI](https://www.radix-ui.com)
*   [Shadcn/UI](https://ui.shadcn.com)

### Project Structure Best Practices
*   Services in `src/lib/` following single-responsibility principle.
*   Types in `src/types/index.ts` for shared data models.
*   Hooks in `src/hooks/` for reusable component logic.
*   Components in `src/components/` organized by feature and type.
*   API routes in `src/app/api/` following REST conventions.

---

## ğŸ§  13. Deep Understanding: How JewelMatrix Works End-to-End

### User Journey: From Task Assignment to Performance Scoring

#### Scenario: Manager Assigns Critical Task to Employee

**Step 1: Task Creation (Manager Dashboard)**
1. Manager clicks "Assign New Task" button on dashboard
2. Opens task creation form (React Hook Form + Zod validation)
3. Fills: title, description, priority (critical), assignees, due date, checklist items
4. Form validates real-time (Zod schema)
5. Manager clicks "Create Task" â†’ API call to `/api/tasks/`

**Step 2: API Processing**
```
POST /api/tasks/
â”œâ”€ Request received with auth token
â”œâ”€ withAdmin() middleware validates authorization
â”œâ”€ Input sanitization (sanitizeFormData)
â”œâ”€ Zod validation against task schema
â”œâ”€ Create task document in Firestore
â”‚  â”œâ”€ Set status: 'assigned'
â”‚  â”œâ”€ Set priority: 'critical'
â”‚  â”œâ”€ Add assignedTo: ['employee_id']
â”‚  â”œâ”€ Calculate initial score weight: 4x (critical)
â”‚  â””â”€ Timestamp: createdAt
â”œâ”€ Log activity in admin_logs
â”œâ”€ Trigger notificationService
â”‚  â”œâ”€ Create notification for employee
â”‚  â”œâ”€ Send email: "New Task Assigned"
â”‚  â””â”€ Store in notifications collection
â””â”€ Return: { success: true, taskId: "task_123" }
```

**Step 3: Employee Receives Notification**
1. In-app toast notification appears on employee's dashboard
2. Email received with task details and link
3. Employee sees new task in "My Tasks" list with status badge "assigned"

**Step 4: Employee Starts Working (Status: in_progress)**
1. Employee clicks task â†’ Task detail view opens
2. Employee reads description and checklist
3. Clicks "Start Working" button â†’ Updates task status
4. API call: `PUT /api/tasks/[taskId]/updates`
5. Firestore updates: `status: 'in_progress'`, `updatedAt: now`
6. Manager gets notification: "Employee started task"

**Step 5: Checklist Completion**
1. Employee completes each checklist item
2. Each checkbox click triggers `PUT /api/tasks/[taskId]/updates`
3. Progress bar updates: "2 of 5 items completed"
4. When all items complete â†’ Task ready for review

**Step 6: Task Submission (Status: pending_review)**
1. Employee clicks "Submit for Review"
2. Task moves to pending_review status
3. Manager gets notification: "Task pending review"
4. Task appears in manager's "Review Queue"

**Step 7: Manager Review & Verification**
Manager options:
- **Verify**: Task is good, move to completed
- **Request Revision**: Provide feedback, task returns to in_progress
- **Reject**: Task fails requirements, back to assigned

**If Verified:**
- Task status â†’ completed
- completedAt timestamp recorded
- enhancedScoringService triggers

**Step 8: Performance Scoring Calculation**
```
EnhancedScoringService.calculateScores()
â”œâ”€ Fetch all completed tasks for this employee
â”œâ”€ Calculate Completion Score
â”‚  â””â”€ Completed Tasks / Total Tasks = 85%
â”œâ”€ Calculate Timeliness Score
â”‚  â”œâ”€ completedAt: 2026-01-25
â”‚  â”œâ”€ dueDate: 2026-01-28
â”‚  â”œâ”€ On time! â†’ +Points
â”‚  â””â”€ Score: 92%
â”œâ”€ Calculate Quality Score
â”‚  â”œâ”€ No revisions on this task
â”‚  â”œâ”€ Score: 100%
â”œâ”€ Calculate KRA Alignment Score
â”‚  â”œâ”€ Task linked to "Sales Execution" KRA
â”‚  â”œâ”€ Check KRA assignment
â”‚  â””â”€ Score: 95%
â”œâ”€ Apply Consistency Bonus
â”‚  â”œâ”€ Check last 4 weeks velocity
â”‚  â”œâ”€ 91% completion rate â†’ Qualifies for bonus
â”‚  â””â”€ +5% bonus
â”œâ”€ Weight formula: (30% Ã— 85) + (30% Ã— 92) + (20% Ã— 100) + (10% Ã— 95) + (10% Ã— bonus)
â”œâ”€ Overall Score = 90.7
â”œâ”€ Store in user_scores collection
â”‚  â”œâ”€ userId: 'employee_123'
â”‚  â”œâ”€ score: 90.7
â”‚  â”œâ”€ weekOf: 2026-01-27
â”‚  â””â”€ breakdown: { completion, timeliness, quality, kra, bonus }
â”œâ”€ Check achievement thresholds
â”‚  â””â”€ Score > 90: Award "Star Performer" badge
â”œâ”€ Trigger notifications
â”‚  â””â”€ "Great work! Your score increased to 90.7"
â””â”€ Update dashboards in real-time (Firestore listeners)
```

**Step 9: Dashboard Updates**
1. Employee dashboard updates:
   - "Your Score: 90.7" (prominent display)
   - "Tasks Completed This Week: 8"
   - "Star Performer Badge" achievement
   - Weekly trend graph shows upward trajectory

2. Manager dashboard updates:
   - "Team Average Score: 87.4"
   - "High Performer Count: 6 of 12"
   - Team performance chart updates

3. Admin dashboard updates:
   - "Org-wide Average: 84.2"
   - "Total Tasks Completed: 324"
   - Real-time analytics refresh

### OKR Alignment: How Tasks Drive Strategy

**Scenario: Quarterly OKR Review**

```
OBJECTIVE: "Increase Customer Satisfaction to 95%"
â”œâ”€ Key Result 1: "Reduce support ticket resolution time to 4 hours"
â”œâ”€ Key Result 2: "Achieve 95% first-contact resolution rate"
â””â”€ Key Result 3: "Increase customer NPS score to 70"
```

**Linking Tasks to Objectives:**
1. Support manager creates OKR in planning interface
2. Links Key Results with target values
3. Assigns team member as "KRA: Customer Support" with target metrics
4. Team creates tasks tied to this KRA:
   - "Process support tickets" (daily recurring)
   - "Implement ticket automation" (one-time project)
   - "Customer feedback analysis" (weekly)

**Real-time Progress Tracking:**
```
Daily Tasks Completed:
â”œâ”€ Task "Process 50 tickets": 50 tickets resolved in 3.5 hours avg
â”œâ”€ Task "Customer feedback": 45 ratings collected, avg 4.2/5 stars
â””â”€ Metric auto-updates: KPI value = 4.2/5 status

Weekly Aggregation:
â”œâ”€ 250 tickets processed (avg 3.8 hours resolution)
â”œâ”€ 234 first-contact resolutions / 250 = 93.6% resolution rate
â”œâ”€ Customer feedback aggregate: 4.3/5 = NPS trending up
â””â”€ Key Result progress: (3.8/4.0) + (93.6/95) + (4.3/5) / 3 = ~94% progress

Quarterly Summary:
â”œâ”€ Multiple weeks of data aggregated
â”œâ”€ Objective progress = Average of all KR progress
â”œâ”€ Result: 91% â†’ "On track for completion"
â””â”€ Adjustments: Can pivot tasks/KRs if needed
```

**Impact on Performance Scores:**
- Tasks aligned to KRA count extra toward "KRA Alignment Score"
- Completing tasks that advance OKRs = higher performance bonus
- Managers can see which teams drive strategy execution
- Executive visibility into strategy-execution linkage

### Multi-Tenant Safety: Why Data Never Leaks

**Security Model:**
```
Every Firestore collection document includes:
â”œâ”€ userId: person who owns this resource
â”œâ”€ departmentId: person's department
â”œâ”€ teamId: person's team (optional)
â””â”€ ownershipPath: hierarchical ownership for querying

Example Task Document:
{
  id: "task_xyz",
  userId: "emp_123",           // Created/assigned to this person
  departmentId: "dept_sales",  // Department
  teamId: "team_enterprise",   // Team
  createdBy: "mgr_456",        // Who created it
  assignedTo: ["emp_123", "emp_124"],  // Can have multiple
  ...
}
```

**Firestore Rules:**
```
match /tasks/{taskId} {
  // Employee can only read their own tasks
  allow read: if request.auth.uid in resource.data.assignedTo
           || request.auth.uid == resource.data.createdBy;
  
  // Can only update own status (not other fields)
  allow update: if request.auth.uid in resource.data.assignedTo
             && request.resource.data.status in validStatusTransitions(oldStatus);
  
  // Managers can update team member tasks
  allow write: if getRole(request.auth.uid) == 'manager'
            && resource.data.departmentId == getEmployeeDept(request.auth.uid);
  
  // Admins can do anything
  allow write: if getRole(request.auth.uid) == 'admin';
}
```

**Server-Side Enforcement:**
- Admin SDK bypasses Firestore rules (intentional for batch operations)
- All admin operations checked with explicit permission code
- activityLogger records: WHO did WHAT to WHICH resource WHEN
- Immutable audit trail cannot be modified retroactively

### Scaling Architecture: From 10 to 10,000 Users

**Small Team (10-50 users):**
- Single Firestore database
- Real-time listeners on all collections
- Cron jobs run daily
- Response times: sub-100ms

**Growth Phase (50-500 users):**
- Implement pagination in API responses (20 items/page)
- Add Firestore composite indexes for complex queries
- Cron jobs run hourly instead of daily
- Cache frequently accessed data (users list, org structure)
- Response times: 100-300ms

**Enterprise Scale (500-10,000+ users):**
- Implement analytics data warehousing
- Separate read replicas for reporting
- Archive old tasks/OKRs to cold storage
- Implement query result caching layer
- Distributed task processing with Cloud Tasks
- Response times: 200-500ms (acceptable for enterprise)

**Data Structure Optimization:**
```
Small scale: Nested data in documents
{
  task: {
    id, title, description,
    assignedTo: ["user1", "user2"],
    checklist: [{ id, text, completed }],
    revisions: [{ id, reason, feedback }]
  }
}

Enterprise scale: References/sharding
{
  task: {
    id, title, description,
    assignedToRefs: ["users/user1", "users/user2"],
    checklistRef: "checklists/task_123",
    revisionsRef: "revisions/task_123"
  }
}
â†’ Reduces document size
â†’ Allows sub-collections to scale independently
â†’ Faster reads of main document
```

### Conflict Prevention: Distributed Updates

**Problem:**
Two managers approve the same task simultaneously:
```
Time 0.0: Manager A fetches task (status: pending_review)
Time 0.1: Manager B fetches task (status: pending_review)
Time 0.2: Manager A marks verified â†’ status: completed
Time 0.3: Manager B marks rejected â†’ status: revision_requested
Result: Last write wins â†’ Inconsistent state!
```

**Solution: Timestamp-based Conflicts**
```
// Get task
const task = await getTask('task_123');
const version = task.version;  // 42

// 5 minutes later...
const updates = { status: 'completed', version: 43 };

// Conditional update: ONLY if version still 42
db.runTransaction(async (transaction) => {
  const currentTask = await transaction.get(taskRef);
  
  if (currentTask.data().version !== version) {
    throw new Error('Conflict: Task was modified');
  }
  
  transaction.update(taskRef, {
    status: 'completed',
    version: 43,
    updatedAt: now
  });
});

// If conflict: Retry or show user "Task was updated, refresh"
```

### Real-time Synchronization: Firestore Listeners

**Example: Dashboard Updates Live as Team Works**

```typescript
// Employee dashboard sets up listener
const unsubscribe = db.collection('tasks')
  .where('assignedTo', 'array-contains', currentUserId)
  .onSnapshot((snapshot) => {
    // This callback fires whenever ANY matching task changes
    const tasks = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    
    // Update React state
    setMyTasks(tasks);
    
    // Analytics listener
    const stats = calculateStats(tasks);
    setStats(stats);
    
    // Manager approval listener
    const pendingReview = tasks.filter(t => t.status === 'pending_review');
    if (pendingReview.length > 0) {
      setReviewNotification(`${pendingReview.length} tasks need review`);
    }
  });

// When task completes elsewhere, listener fires automatically
// No polling, no refresh button, real-time sync
```

**Performance Considerations:**
- Listeners use bandwidth (Firestore bills on reads)
- Complex queries with listeners are expensive at scale
- Solution: Use aggregation queries for summaries, detail listeners for specifics

### Error Handling & Resilience

**Network Failures:**
```typescript
try {
  await updateTask(taskId, { status: 'completed' });
} catch (error) {
  if (error.code === 'permission-denied') {
    showError("You don't have permission to update this task");
  } else if (error.code === 'not-found') {
    showError("Task no longer exists");
  } else if (error.code === 'unavailable') {
    // Network error, retry
    setTimeout(() => updateTask(taskId, { status: 'completed' }), 3000);
  } else {
    showError("Unknown error, please try again");
  }
}
```

**Data Validation:**
```typescript
// Before sending to API
const schema = z.object({
  title: z.string().min(3).max(200),
  priority: z.enum(['low', 'medium', 'high', 'critical']),
  dueDate: z.coerce.date().min(new Date())
});

const result = validateData(schema, formData);
if (!result.success) {
  showErrors(result.errors);  // Display validation errors to user
  return;
}

// Server also validates (never trust client)
const serverValidation = schema.safeParse(req.body);
if (!serverValidation.success) {
  return Response.json({ error: 'Invalid data' }, { status: 400 });
}
```

---

## 15. Database Query Patterns & Performance Optimization

### Understanding Query Efficiency in JewelMatrix

Query efficiency is fundamental to JewelMatrix's real-time responsiveness. The system relies on Firestore's NoSQL structure, which means query patterns directly impact both performance and billing. Unlike traditional SQL databases, Firestore charges per document read regardless of how many fields you actually use, making query optimization both a performance and cost consideration.

#### Pagination Strategies

JewelMatrix uses cursor-based pagination rather than offset-based pagination. This design choice emerges from Firestore's inability to efficiently skip documentsâ€”there's no native "skip 100 documents" operation. Instead, the system remembers the last document read (the cursor) and starts the next query after that position. This means pages remain consistent even if data changes between requests, and pages never skip or duplicate records.

When fetching the next page, the system requests one extra document beyond the page size to determine if more results exist, avoiding the need for a separate count query.

#### Aggregation and Analytics

For analytics queries that need counts or sums, the system uses Firestore's aggregation queries when available, which operate differently from regular document reads. Rather than fetching entire documents to count them, aggregation queries work at the index level, dramatically reducing cost and latency. This is particularly important for KPI calculations that need to count completed tasks or sum scores across users.

#### Complex Filtering with Multiple Conditions

Firestore enforces constraints on which field combinations can be queried together. When you need to filter on status, due date, and assigned user simultaneously, the system relies on composite indexes that are explicitly defined. JewelMatrix automatically creates these indexes in firestore.indexes.json for all commonly-used query patterns (tasks by assignee and status, by department and due date, etc.).

### Common Query Bottlenecks and Why They Occur

**The N+1 Query Problem**: A common mistake is fetching all tasks first, then for each task, fetching the assigned user's details. This creates one query to fetch tasks plus N additional queries to fetch users, scaling linearly with task count. JewelMatrix mitigates this through denormalizationâ€”the task document includes frequently-accessed user fields like name, email, and department, eliminating the need for the extra queries.

**Missing Indexes**: Without composite indexes, Firestore must scan all documents in a collection to answer queries. With hundreds of thousands of tasks, this becomes prohibitively slow. The system pre-defines all composite indexes needed for its query patterns, ensuring every query can use indexed lookups.

**Array Query Limitations**: Firestore's `array-contains-any` operator cannot be combined with other where clauses in a single query. For queries needing to find tasks assigned to user A OR user B where status is completed, the system executes separate queries for each user and merges the results in the application layer, deduplicating by document ID.

**Listener Scope**: Real-time listeners trigger reads whenever any matching document changes. A listener on all tasks means paying for reads every time any task changes anywhere in the system. JewelMatrix scopes all listeners with where clausesâ€”listening only to tasks assigned to the current user, or tasks in the current user's departmentâ€”keeping listener costs proportional to actual data scope rather than database size.

**Document Granularity**: Firestore charges per document read, not per field. Fetching a 1KB document or a 100KB document costs the same. This design principle influences how JewelMatrix structures dataâ€”it denormalizes commonly-accessed fields into main documents rather than spreading information across many smaller documents.

### Firestore Indexing Requirements

Composite indexes are created for all query patterns that use multiple where clauses or orderBy with filters. For tasks, indexes exist for:
- (assignedTo ascending, status ascending, createdAt descending) - "my tasks by status"
- (departmentId ascending, dueDate ascending, status ascending) - "team's overdue tasks"
- Similar patterns for objectives, KRAs, and KPIs

These indexes enable Firestore to answer queries in logarithmic time rather than requiring full collection scans.

### Pagination Cursor Mechanics

Pagination cursors represent a specific point in a sorted result set. Rather than being a page number, a cursor is opaque data that records the last document's ID and sort key. When requesting the next page, the system uses this cursor to start the query after that position. This approach handles data mutations gracefullyâ€”if documents are added or deleted between page requests, the cursor ensures the next page continues smoothly from where the previous page ended, with no gaps or duplicates.

---

## 16. State Management & Data Flow Patterns

### How Authentication State Flows Through JewelMatrix

Authentication is the foundation of JewelMatrix's state architecture. When a user first logs in via Firebase Auth, their identity is verified through a JWT token. The system then fetches the user's profile from Firestore, which includes their role (admin, manager, or employee) and department assignment. This profile information is stored in React Context at the application root, making it accessible to every component without prop drilling.

Context itself is a client-side state mechanismâ€”it doesn't persist across page reloads. To solve this, JewelMatrix hooks into Firebase's `onAuthStateChanged` listener, which persists authentication state across browser restarts. This means when a user closes and reopens the app, Firebase automatically recognizes them, re-fetches their profile, and restores the context.

The key insight is that authentication and authorization (knowing who the user is and what they're allowed to do) must be connected to Firestore at all times. When a user's role changes (promoted from employee to manager), the change is made in the user's Firestore document, and the next page load or listener update brings the context into sync.

### Client State vs Server State Decision Framework

JewelMatrix makes a fundamental distinction: **client state** lives in React (useState, Context) and disappears on page refresh, while **server state** lives in Firestore and persists across sessions.

Data that needs to persist across browser sessions must be stored on the serverâ€”this includes tasks, OKRs, user roles, and scores. Data that only matters for the current session can be client-sideâ€”current filter selections, form input values, UI animation states, or temporary calculations.

Data that flows from multiple sources simultaneously (updated by other users in real-time) must be server state with listeners. A task assigned to multiple people needs everyone's changes synchronized, which only works with server-side persistence and real-time listeners.

Data that requires an audit trail for compliance must be server state. JewelMatrix logs every significant action to `admin_logs`, and these logs themselves must be in Firestore, not in memory.

Data that affects business logic calculations must be server state, computed on the server. If score calculations happened on the client, users could manipulate their own scores. By computing on the server, JewelMatrix ensures the source of truth is authoritative.

### Real-Time Synchronization Architecture

JewelMatrix achieves real-time updates through Firestore listeners, which establish persistent connections to the database. When a user opens their task list, a listener subscribes to "all tasks assigned to this user." Every time a task changes (status updated, due date modified), Firestore sends an update to the listener, which updates React state, which triggers a re-render.

This happens for multiple concurrent usersâ€”if manager updates a task's status, every employee with that task open sees the update within milliseconds. This is the "real-time" aspect of JewelMatrix's architecture.

Listeners must be carefully scoped to avoid excessive bandwidth and billing. Listening to all tasks in the database is much more expensive than listening only to tasks relevant to the current user. Every task change anywhere would trigger listener updates, even if the user doesn't care about most tasks.

Listeners also require cleanup. When a component unmounts (user navigates away from the task list), the listener must be unsubscribed to stop consuming bandwidth. JewelMatrix uses React useEffect cleanup functions to manage listener lifecycle.

### Cache Invalidation Philosophy

JewelMatrix uses caching to avoid redundant Firestore reads, but caching creates a consistency problem: when does cached data become stale?

The system implements TTL-based caching (Time To Live) for non-critical data. For example, the list of team members is cached for 1 minute. This means within that minute, if someone is added to the team, existing user's screens won't see it immediatelyâ€”but after 1 minute, the cache expires and the next request fetches fresh data.

For critical data (tasks, user roles), caching is either minimal or combined with listeners. A listener ensures cached data immediately reflects server changes, giving the best of both worlds: cache efficiency for repeated access plus real-time updates when others modify data.

Manual cache invalidation happens explicitlyâ€”when a user adds a team member, the code calls `invalidate()` immediately, forcing the next access to fetch fresh data from Firestore rather than waiting for the TTL to expire.

---

## 17. Business Logic Deep Dive

### Understanding Task State Transitions

Tasks in JewelMatrix flow through a specific state machine with well-defined allowed transitions. A task begins as "not_started," moves to "assigned" when given to a team member, transitions to "in_progress" when work begins, and eventually reaches "completed" after review. However, not every transition is validâ€”you cannot jump directly from "assigned" to "completed," and you cannot move backward from "completed" to "in_progress."

This state machine prevents workflow violations. A task cannot be marked completed without first being submitted for review ("pending_review" status). A completed task can only move to "archived" status. A cancelled task is terminalâ€”it cannot be uncancelled. These rules are enforced at the server level, not just in the UI, ensuring no user can bypass them through API manipulation.

Tasks can also enter an "overdue" state when their due date passes without completion. This is a special state that doesn't require explicit user actionâ€”the system detects overdue tasks and marks them automatically. An overdue task must return to "in_progress" to continue work, enforcing visibility of late deliverables.

The state machine also checks prerequisites. Before a task can move to "pending_review," all checklist items must be completed. Before moving to "completed," if the task requires manager approval, that approval must have been granted. These guards prevent incomplete work from being marked done.

### Handling Score Recalculation Complexities

Score recalculation is central to JewelMatrix's performance metrics, but it involves subtle complexities. When a task is marked completed, the assignee's score increases. But what if the task is then unmarked? The score must decrease back. What if a task is assigned to multiple people and only one completes their portion? The system tracks individual completion statuses for each assignee, only considering the task fully complete when all assignees have finished.

Another edge case: backdating. If a manager later realizes a task was actually completed earlier than recorded (perhaps the employee forgot to mark it done), the system allows backdating the completion up to 7 days. This triggers a recalculation of scores for the entire week affected, recalculating historical performance metrics to reflect the corrected timeline.

All score recalculations must be transactionalâ€”the task status update and score recalculation happen atomically, or not at all. This prevents inconsistent states where the task shows completed but the score hasn't updated yet.

### The OKR-Task-Score Cascade

JewelMatrix links tasks to Key Results (KRs) through KRAs (Key Result Areas). When a task linked to a KRA is completed, it increments the KPI (Key Performance Indicator) for that KRA in the current week. As KPIs accumulate, the KR progress percentage increases. As KRs progress, the parent Objective progress increases.

This cascade means completing a task doesn't just affect your individual scoreâ€”it cascades up through the entire strategy hierarchy. A sales representative completing a "close customer" task increments a KRA like "new customer acquisition," which moves toward a KR like "acquire 50 new customers," which contributes to an Objective like "grow revenue by 30%."

The cascade operates on summationâ€”an Objective's progress is the average of its KRs' progress. A KR's progress is calculated from its target value versus current value. Different KR types (percentage complete, number of units, currency, boolean yes/no) have different progress calculation formulas.

### Validation and Business Rule Enforcement

JewelMatrix enforces business rules at the server level in dedicated validation classes. Deadline extensions require a justification of at least 10 characters and can't exceed a maximum length (5 days, or however many days already overdue). A task cannot be extended beyond a certain point to prevent indefinite delays.

Completion requires certain preconditions: the task must have a due date, any required manager approval must be present, and there must be no pending revision requests. These rules ensure that tasks marked complete genuinely represent finished work meeting all requirements.

---

## 18. Common Gotchas & Solutions

### Race Conditions and Concurrent Modifications

When multiple users update the same task simultaneously, Firestore's "last write wins" behavior means the final state depends on which request arrives lastâ€”potentially not the intended state. Imagine two managers updating the same task: one changes status to "completed" while another changes it to "blocked." Whichever update reaches Firestore second overwrites the first, and the first manager's work is lost.

JewelMatrix mitigates this using optimistic locking with version numbers. Each task document includes a version field that increments on every update. When updating, the client sends both the new data and the current version. The server checks whether the document's version still matches; if another user has modified it, the version will have changed, and the update is rejected. The client is then instructed to refresh and retry, ensuring users don't accidentally overwrite each other's changes.

### Firestore Billing Gotchas

Listeners are deceptively expensive. Setting up a listener on a collection triggers one read per document in that collection every time any document changes. If you listen to all tasks without filtering, and 10,000 task changes occur daily, you're charged for 10,000 reads daily just from the listeners.

JewelMatrix applies strict listener scopingâ€”listeners always include where clauses limiting them to relevant data. A user's task list listener only watches tasks assigned to that user, not the entire task collection. This keeps listener costs proportional to data volume actually affecting the user.

Batch operations are essential for cost control. Updating 100 tasks individually is 100 write operations. Batching those same updates into one batch commit is 1 write operation, reducing cost by 100x.

### Pagination Edge Cases

Cursor-based pagination appears simple but harbors subtle bugs. If you fetch exactly pageSize documents and return them without checking if more exist, you can't tell whether the page is full or you've reached the end of results. The solution is fetching one extra documentâ€”if you get pageSize + 1 documents, more exist. If you get fewer, you've reached the end. You return only the first pageSize documents to the client, along with a hasMore flag.

Another issue: if documents are deleted between page requests, the cursor might point to a non-existent document. Firestore handles this gracefully by simply starting after the next available document, but you must be aware the behavior exists.

### Server Timestamps vs Client Times

Client clocks are unreliable. A user's device might have the wrong time, causing confusion when trying to set due dates or compare timestamps. Whenever the server needs an authoritative timestamp (task created, marked complete), JewelMatrix uses Firebase's server timestamp, which is generated by Google's servers and guaranteed accurate.

Client-provided timestamps (due dates) are differentâ€”users choose when tasks should be done. These are validated on the server (due dates must be in the future) but stored as-is. System-generated timestamps like createdAt and completedAt always use server timestamps.

### Firestore Array Query Limitations

Firestore's array-contains-any operator cannot be combined with other where clauses in a single query. If you need tasks assigned to user A OR user B where status is completed, Firestore rejects the query. The workaround is running separate queries (tasks for user A with status completed, tasks for user B with status completed) and merging results in the application layer, then deduplicating by document ID.

---

## 19. Testing Strategy

### Three-Layer Testing Approach

JewelMatrix employs three distinct layers of testing, each validating different aspects of the system.

**Unit testing** focuses on individual service methods in isolation. The taskService.createTask method is tested with valid input (should create successfully), invalid input (past due date should be rejected), missing required fields (no assignees should be rejected), and edge cases. Unit tests mock the Firestore database, replacing it with fake implementations that respond predictably. This allows testing service logic without touching the real database, making tests fast and reliable.

**Integration testing** validates that API routes work end-to-end with real authentication and input validation. A test makes an HTTP request to POST /api/tasks with valid authentication headers and data, expecting a 200 response with a taskId. Another test sends the same request without authentication and expects 401. Another test sends invalid data (task title too short, invalid priority) and expects 400 with error details. Integration tests use actual authentication tokens (test tokens for the test database) and validate the complete request-response flow.

**Business logic testing** specifically validates the TaskBusinessRules class. Valid status transitions (assigned â†’ in_progress) should pass. Invalid transitions (completed â†’ assigned) should fail. Attempting to mark a task complete without completing all checklists should fail. These tests ensure the state machine and validation rules work correctly.

Performance testing verifies that queries complete within acceptable timeframes. Fetching 100 tasks should complete in under 500ms. Calculating scores for 1000 users should complete in under 30 seconds. These benchmarks catch performance regressions early.

### Testing Business Rules

JewelMatrix's business rules are criticalâ€”they enforce constraints that prevent invalid data. Testing ensures rules are enforced correctly. The system tests that:
- Status transitions respect the state machine (certain transitions are forbidden)
- Completion requires prerequisites (all checklists done, approvals obtained)
- Extensions have limits (can't extend indefinitely)
- Scores are calculated correctly given task priority and weight

### Firebase Mocking

Unit tests need to test logic without touching the real database. JewelMatrix mocks the Firestore SDK, replacing collection(), doc(), get(), update(), and other methods with Jest mock functions. These mocks can be configured to return specific values, throw errors, or track how many times they were called. This isolation allows testing service methods in milliseconds rather than waiting for network calls to Firebase.

### Performance Benchmarking Philosophy

Performance benchmarks establish baselinesâ€”"fetching 100 tasks should take < 500ms." These benchmarks are tested in CI/CD pipelines. If a code change causes performance to degrade (new code takes 600ms instead of 500ms), the test fails, alerting developers to a regression. This prevents the system from gradually degrading over time as developers make small changes that individually seem harmless but collectively degrade performance.

---

## 20. Debugging Guide: Tracing Issues Through the System

### End-to-End Bug Tracing Methodology

When a user reports "my task status didn't update," debugging requires traversing the entire system layer by layer. The methodology is:

**Layer 1: Client Side** â€” Check if the update request was even sent. Browser console logs reveal whether the JavaScript code attempted the update. DevTools Network tab shows the HTTP request: Was it sent? What status code was returned? What was in the request body and response?

**Layer 2: API Route** â€” The API route receives the request, validates it, and initiates the Firestore update. Checking API logs shows: Did auth validation pass? Was the status value valid? Did the task exist? Did the status transition pass business rule validation?

**Layer 3: Firestore Database** â€” The actual database layer. Firebase Console shows whether the task document was updated: Is the status field actually changed? Is the updatedAt timestamp recent? This confirms whether the database update happened.

**Layer 4: Activity Logs** â€” JewelMatrix logs all state-changing operations to admin_logs. Querying this collection for the task shows: Was a task_status_updated action logged? What was the timestamp? What was the old vs new status?

**Layer 5: Real-time Listeners** â€” If the database has the new status but the user's screen doesn't reflect it, the issue is the listener. Maybe the listener unsubscribed, or maybe a JavaScript error prevents state updates. Checking listener debug logs reveals whether snapshots are being received.

**Layer 6: Browser Storage** â€” LocalStorage contains auth tokens. If the token is expired, requests fail silently. Checking LocalStorage reveals whether a valid token exists.

This systematic approach eliminates confusion about where the problem lives. Problems are either in frontend code, API validation, database operation, logging, real-time synchronization, or authenticationâ€”narrowing the diagnosis through methodical layers.

### Understanding Common Errors

**"Permission denied"** means the Firestore security rules rejected the operation. The user either doesn't have the necessary role, isn't assigned to the task, or the rules specifically prohibit this action. The solution is checking rules against the user's actual role in the users collection.

**"Document not found"** means querying a non-existent document. The ID might be wrong (typo, case sensitivity), the document was deleted, or it was never created. Adding logs of the ID being queried quickly reveals which.

**"Invalid field path"** occurs when referencing a field that doesn't exist. Firestore is strict about field namesâ€”a typo means the query fails. Using dot notation for nested objects requires the parent field to exist.

**"Cannot be null"** indicates a required field is missing. The data being saved has an undefined field that the schema requires. Adding a default value or ensuring the client always provides the field fixes this.

**"Array index out of bounds"** happens when accessing array elements that don't exist. Using optional chaining (?.[0]) or find() instead of direct array access ([0]) prevents these crashes.

### DevTools and Monitoring Strategies

Browser DevTools Network tab reveals API call failures, slow requests, and response data. React DevTools Profiler measures component rendering performance. Firebase Console Rules Playground tests security rules before deploying. Cloud Logging shows server-side errors, timeouts, and cron job execution.

Real-time listeners can be monitored by setting up subscriptions in the console and watching for update events. Performance profiling identifies slow database queries or expensive computations.

---

## 21. Monitoring & Observability Strategy

### Understanding System Health Through Metrics

JewelMatrix's observability is built on collecting and tracking specific metrics that indicate system health and business performance.

**Performance metrics** measure query speed and API responsiveness. Average query time shows how long typical database reads take. 95th and 99th percentile response times reveal worst-case performanceâ€”if 99th percentile is slow, some users experience poor performance. These metrics immediately surface database bottlenecks (missing indexes) or code inefficiencies.

**Reliability metrics** track success vs failure rates. Error rate measures what percentage of requests fail. Task failure rate might track tasks that failed validation or couldn't be created. Monitoring these reveals systemic problemsâ€”if error rate suddenly jumps, something broke.

**Business metrics** answer organizational questions. How many tasks completed today? What's the average score today compared to yesterday? How many tasks are overdue? These metrics inform leadership about execution and performance.

**Infrastructure metrics** track resource consumption and cost. Firestore read operations, write operations, and daily cost directly impact budgets. Monitoring document count reveals database growth and informs scaling decisions.

**User metrics** measure engagement. Active users today shows who's using the system. Average tasks per user reveals adoption patterns. Are heavy users or light users dominating? This informs onboarding and adoption strategies.

### Error Tracking Philosophy

Errors occur in production despite testing. JewelMatrix captures errors with contextâ€”when an error happens, the system also records what the user was doing, which user encountered it, which system component failed. This context is crucial for debugging.

Errors are aggregated and deduplicated. If the same error happens 1,000 times, it's reported once with a count of 1,000, highlighting the most critical issues. Alerts fire on new errors or error rates exceeding thresholds.

### Performance Monitoring Approach

Every API call is timed. Slow requests (> 1 second) are logged as warnings. Failed requests (status >= 400) are logged as errors. This creates an observable record of system performance. When users report slowness, historical performance data reveals whether it's recent or ongoing.

Database queries are monitored for slow execution. Queries taking more than expected time indicate missing indexes or suboptimal queries, allowing developers to optimize before customers complain.

### Metrics Collection Strategy

Metrics are calculated by querying Firestoreâ€”completed tasks today, overdue count, user scores. These queries run periodically (every 5 minutes) and results are stored in a metrics collection, creating a time-series record of system state. This historical data reveals trends: Is performance degrading over time? Are more tasks going overdue? Is engagement declining?

Alerting rules trigger when metrics exceed thresholds: "error rate > 5%" or "average response time > 1000ms" generates alerts so problems are caught early, before customers notice.

---

## 22. Integration Patterns & Service Communication

### Service-to-Service Communication Modes

JewelMatrix services communicate through three fundamental patterns, each suited to different scenarios.

**Synchronous Direct Calls**: One service calls another directly and waits for the response. When assigning a task to an employee, the task service directly calls the user service to verify the employee exists and is active. This ensures immediate feedbackâ€”if the employee doesn't exist, the assignment fails immediately. The downside is tight coupling: the task service depends on the user service being available. If the user service is slow or down, task assignment becomes slow or fails.

**Asynchronous Event-Driven**: A service publishes an event ("task completed") and other services listen for it. When a task completes, the task service updates the database and emits a "task:completed" event. Multiple services subscribe to this event: scoring service recalculates scores, notification service sends notifications, analytics service updates metrics, OKR service updates progress. None of these services need to know about each other; they're decoupled.

**Transaction-Based Atomic Operations**: Multiple updates must happen atomicallyâ€”all succeed or all fail. Transferring a task from one user to another involves: deducting points from the old user's score, adding points to the new user's score, updating the task's assignee, and logging the activity. If any of these fails partway through, the system enters an inconsistent state. Transactions ensure all four operations happen together or none do.

### Webhook Integration Patterns

Webhooks allow external systems to react to JewelMatrix events. When registering a webhook, you provide a URL and an event type ("task:completed"). When that event occurs, JewelMatrix sends an HTTP POST to the webhook URL with event data. The external system processes itâ€”maybe updating a CRM, sending Slack notifications, or triggering workflows.

Webhooks must be reliable despite network failures. JewelMatrix implements retry logic with exponential backoffâ€”first retry after 1 minute, next after 2 minutes, then 4 minutes. After a configurable number of retries (3 by default), the webhook is disabled. This prevents hammering a broken endpoint forever.

Webhook payloads are cryptographically signed so the receiver can verify they came from JewelMatrix. The signature is a HMAC-SHA256 hash of the payload using a shared secret, preventing spoofed webhooks.

### Resilience Patterns

**Retry Logic with Exponential Backoff**: When a request fails (network timeout, 500 error), immediately retrying is often futileâ€”the server is still broken. Waiting before retrying increases chances of success. Exponential backoff (wait 100ms, then 200ms, then 400ms) prevents overwhelming a recovering server with immediate retries.

**Circuit Breaker Pattern**: If a service fails repeatedly (5 consecutive failures), further requests fail immediately without attempting to reach the broken service, fast-failing rather than timing out. After a timeout period (1 minute), a "test" request is sent. If successful, the circuit "closes" and normal requests resume. If not, the circuit stays "open." This prevents cascading failures where a broken dependency takes down dependent services.

**Timeout Configuration**: Every network call includes a timeout. If the remote service doesn't respond within the timeout, the request fails rather than hanging indefinitely. This prevents requests from accumulating and exhausting resources.

---

## 23. Security Deep Dive

### Authentication vs Authorization

Authentication answers "who are you?" Authorization answers "what are you allowed to do?"

**Authentication** is handled by Firebase Authentication. Users log in with email and password (or social login), and Firebase issues a JWT token verifying their identity. Every subsequent request includes this token, which the server verifies cryptographically. If someone tampers with the token, the cryptographic signature fails and authentication is rejected.

**Authorization** is enforced through Firestore security rules and server-side checks. A user might be authenticated (we know who they are) but not authorized (they shouldn't access this data). Firestore rules enforce this at the database layerâ€”a user can only read tasks assigned to them, or tasks in their department if they're a manager, or all tasks if they're an admin.

### Firestore Rules Philosophy

Firestore rules act as a second authentication layer. Even if a user managed to bypass all API validation, the rules prevent unauthorized database access. Rules use helper functions to evaluate conditions: `isAuthenticated()` checks if a token exists, `isAdmin()` checks the user's role from the users collection, `canEditTask()` checks multiple conditions (user is assigned, user created it, or user is a manager in the same department).

Rules follow a deny-by-default principle. The last rule denies all access unless explicitly allowed by more specific rules. This prevents accidental exposure.

Brute-forcing rules is difficult because they're statelessâ€”every check must pass independently. Rules can't be bypassed by exploiting race conditions or timing attacks because there's no application state to corrupt.

### Token Validation and Expiration

JWT tokens have expiration times. After expiration, they become invalid. In production, JewelMatrix validates that tokens haven't expired and that the user's email is verified. An expired token is rejected immediately, forcing re-authentication.

Tokens contain claimsâ€”information about the user (UID, email, custom claims like role). These claims are cryptographically signed so users can't forge tokens claiming to be admin if they're just an employee.

### Input Sanitization and Validation

User input is never trusted. A task title might contain JavaScript code. Storing this and later displaying it in the UI could execute the script in other users' browsers.

JewelMatrix sanitizes HTML input, removing potentially dangerous tags and attributes. A task description can include formatting (bold, italics) but not scripts or event handlers. Input is also validated: task titles must be at least 3 characters, descriptions must be under a character limit, and assignee IDs must be valid user IDs.

### Common Attack Vectors and Defenses

**Injection Attacks**: Although Firestore is NoSQL, the principle appliesâ€”never construct queries using user input directly. Instead, validate user input against a whitelist before using it.

**Broken Access Control**: Checking permissions before returning data. A user shouldn't be able to request a specific task and get details about someone else's work. The server verifies the user is assigned to the task (or is a manager, or admin) before responding.

**Insecure Direct Object References**: Users might guess or brute-force object IDs. JewelMatrix prevents this by always verifying permissionsâ€”even if a user guesses the correct task ID, they can't access it without proper authorization.

**Rate Limiting**: Without limits, a user could hammer the API with thousands of requests, causing a denial-of-service. Rate limiting restricts requests per user per time window, preventing abuse.

**Unvalidated Redirects**: After login, the app might redirect to a URL provided in the request. An attacker could provide a malicious URL, redirecting users to a phishing site. JewelMatrix whitelists allowed redirect domains, preventing this.

---

## 24. Advanced Performance Optimization Strategies

### Database Query Optimization Concepts

**Denormalization Tradeoff**: Fetching a task requires knowing the assignee's name, email, and department. The normalized approach: fetch the task, then fetch the user document, requiring 2 database operations. The denormalized approach: store assignee name, email, and department directly in the task document. This is a single query but requires synchronizationâ€”when the user's name changes, all their task documents must update.

JewelMatrix denormalizes frequently-read fields but not everything. Denormalization is worthwhile when the read-to-write ratio is high (reading the field many times vs changing it rarely). User names change infrequently but are read constantly, making it worth denormalizing. Department assignments change rarely but apply to many tasks.

**Aggregation Instead of Fetching**: Counting completed tasks the naive way fetches every task document and counts them in code. Firestore's aggregation queries count at the index level, returning just the count without fetching documents. This is dramatically faster and cheaper, especially for large result sets.

**Batch Operations**: Updating 100 tasks individually is 100 write operations. Batching those updates into a single batch commit is 1 operation, reducing cost and latency by 100x. The downside is atomicityâ€”if the batch partially fails, some documents update and others don't. For operations that don't require all-or-nothing semantics, batching is always preferred.

### Caching Strategy

Caching reduces database queries by storing recently-fetched data in memory. A user's profile is fetched when they log in, cached, and served from memory for subsequent requests. Cache entries expire (TTLâ€”Time To Live) after a duration (5 minutes). If a user's profile changes, cached versions expire naturally after TTL, or manually invalidated immediately if consistency is critical.

The caching decision is: "Can this data be stale?" User profile can be 5 minutes staleâ€”that's acceptable. A task status can't be staleâ€”if the user just completed a task, they see the completion immediately, not 5 minutes later. For consistency-critical data, caching is minimal or combined with real-time listeners.

### Frontend Performance Optimization

**Code Splitting**: Large JavaScript bundles slow page loads. Code splitting breaks the bundle into smaller chunks. The analytics page's code only loads when the user navigates to that page, not on initial load. Heavy visualization components are loaded only when needed.

**Lazy Loading**: Images and components are loaded on-demand. Non-critical images are lazy-loadedâ€”they load only when approaching visibility, reducing initial page load. Skeletons display while content loads, showing UI structure before data arrives.

**Memoization**: React components re-render when props or state change. A TaskCard component rendering thousands of tasks would re-render all of them if parent state changes, even if individual task data hasn't changed. Memoization caches the rendered outputâ€”if props haven't changed, the cached output is used without re-rendering.

**Virtual Scrolling**: Rendering thousands of DOM nodes is expensive. Virtual scrolling renders only visible items. If you have 10,000 tasks but can see 20 at a time, only 20 DOM nodes exist. Scrolling updates the visible range, re-using DOM nodes. This keeps the DOM small and performant regardless of dataset size.

### Understanding Performance Tradeoffs

Every optimization trades something for something else. Denormalization trades write complexity (keeping multiple documents in sync) for read speed. Caching trades consistency (data might be stale) for performance. Code splitting trades initial load time for chunk load time when needed. Understanding these tradeoffs helps make informed optimization decisionsâ€”optimize the bottleneck, not everything.

---

## ğŸ“‹ 14. Project Wisdom: Best Practices & Anti-Patterns

### âœ… Best Practices to Follow

1. **Always use Server Components by default**
   - Load data in Server Components
   - Use `'use client'` sparingly for interactivity only
   - Reduces JavaScript bundle size

2. **Type Everything**
   - Use `@/types` for shared type definitions
   - Enable TypeScript strict mode
   - No `any` types without justification

3. **Validate at Boundaries**
   - API routes: Use Zod schemas
   - Forms: React Hook Form + Zod
   - Server actions: Validate input before processing

4. **Log Everything for Audit**
   - activityLogger on all state-changing operations
   - Immutable audit trail for compliance
   - Query activity logs for debugging

5. **Keep Services Modular**
   - One responsibility per service
   - Reuse services across API routes
   - Export for both client and server as appropriate

6. **Optimize Firestore Queries**
   - Always add proper where/orderBy clauses
   - Create composite indexes in firestore.indexes.json
   - Limit result size with `.limit(pageSize)`
   - Denormalize data for read-heavy queries

### âŒ Anti-Patterns to Avoid

1. **Don't fetch all data**
   ```typescript
   // âŒ WRONG: Fetches every task in database
   const allTasks = await db.collection('tasks').getDocs();
   
   // âœ… RIGHT: Fetch only what you need
   const myTasks = await db.collection('tasks')
     .where('assignedTo', 'array-contains', userId)
     .limit(50)
     .getDocs();
   ```

2. **Don't log sensitive data**
   ```typescript
   // âŒ WRONG: Logs password
   activityLogger.log({ action: 'login', password: plaintext });
   
   // âœ… RIGHT: Log only necessary info
   activityLogger.log({ action: 'login', userId });
   ```

3. **Don't use client state for critical business logic**
   ```typescript
   // âŒ WRONG: Client can manipulate score
   const [score, setScore] = useState(0);
   const newScore = score + points;  // Cheating!
   
   // âœ… RIGHT: Calculate on server
   const newScore = await api.updateScore(userId, points);
   ```

4. **Don't ignore error handling**
   ```typescript
   // âŒ WRONG: Crashes silently
   await updateTask(taskId, data);
   
   // âœ… RIGHT: Handle errors gracefully
   try {
     await updateTask(taskId, data);
     showSuccess("Task updated");
   } catch (error) {
     showError(`Failed to update: ${error.message}`);
   }
   ```

5. **Don't query without pagination**
   ```typescript
   // âŒ WRONG: Memory explosion with 10K users
   const users = await db.collection('users').getDocs();
   
   // âœ… RIGHT: Paginate results
   const pageSize = 50;
   let query = db.collection('users').limit(pageSize);
   let hasMore = true;
   while (hasMore) {
     const docs = await query.getDocs();
     // Process page...
     if (docs.size < pageSize) hasMore = false;
     else query = query.startAfter(docs.docs[docs.size - 1]);
   }
   ```

---

*Â© 2026 JewelMatrix. Standardizing Organizational Excellence.*
